1. 推荐的重构思路
1.1. 设计一个 TunnelConnectionManager（或 TunnelSessionManager）
负责维护 client_id/session_id 到 tx/rx 的映射。
提供线程安全的注册、查找、移除接口。
支持多 client、多 stream、多协议的高效查找。

```
use std::collections::HashMap;
use tokio::sync::{mpsc, Mutex};
use std::sync::Arc;

pub struct TunnelConnectionManager {
    // client_id -> tx
    client_txs: Mutex<HashMap<String, mpsc::Sender<TunnelMessage>>>,
    // session_id -> (client_id, tx)
    session_map: Mutex<HashMap<String, (String, mpsc::Sender<TunnelMessage>)>>,
}

impl TunnelConnectionManager {
    pub fn new() -> Self {
        Self {
            client_txs: Mutex::new(HashMap::new()),
            session_map: Mutex::new(HashMap::new()),
        }
    }

    // 注册新 client
    pub async fn register_client(&self, client_id: String, tx: mpsc::Sender<TunnelMessage>) {
        self.client_txs.lock().await.insert(client_id, tx);
    }

    // 注册新 session
    pub async fn register_session(&self, session_id: String, client_id: String) {
        if let Some(tx) = self.client_txs.lock().await.get(&client_id).cloned() {
            self.session_map.lock().await.insert(session_id, (client_id, tx));
        }
    }

    // 查找目标 tx
    pub async fn get_tx_by_client(&self, client_id: &str) -> Option<mpsc::Sender<TunnelMessage>> {
        self.client_txs.lock().await.get(client_id).cloned()
    }

    pub async fn get_tx_by_session(&self, session_id: &str) -> Option<mpsc::Sender<TunnelMessage>> {
        self.session_map.lock().await.get(session_id).map(|(_, tx)| tx.clone())
    }

    // 移除 client/session
    pub async fn remove_client(&self, client_id: &str) {
        self.client_txs.lock().await.remove(client_id);
        self.session_map.lock().await.retain(|_, (cid, _)| cid != client_id);
    }
    pub async fn remove_session(&self, session_id: &str) {
        self.session_map.lock().await.remove(session_id);
    }
}
```
