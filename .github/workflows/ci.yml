name: CI

on:
  push:
    branches: [main, "fix/**", "feat/**"]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # ─────────────────────────────────────────────────────────────────────────────
  # Job 1: Unit tests + clippy
  # ─────────────────────────────────────────────────────────────────────────────
  unit-tests:
    name: Unit Tests & Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: cargo test (all workspace crates)
        run: cargo test --workspace

      - name: cargo clippy (deny warnings)
        run: cargo clippy --workspace -- -D warnings

  # ─────────────────────────────────────────────────────────────────────────────
  # Job 2: Integration tests — end-to-end, all protocols
  #
  # Local backends (ci-helpers binaries, always reachable):
  #   http-echo-server  127.0.0.1:9999  — HTTP/1.1 + HTTP/2 JSON echo
  #   ws-echo-server    127.0.0.1:8765  — WebSocket frame echo
  #   grpc-echo-server  127.0.0.1:50051 — gRPC Health service
  #
  # External backends (real internet, continue-on-error):
  #   echo.free.beeceptor.com:443       — HTTP echo (HTTPS)
  #   wss://echo.websocket.org          — WebSocket echo (WSS)
  #   https://grpc-echo.semior.dev:443  — gRPC echo (HTTPS)
  #
  # /etc/hosts maps test domains to 127.0.0.1 for Host-header–based routing:
  #   echo.local / ws.local / grpc.local → tunnel-server entry_port :8080
  #
  # Tunnel topology:
  #   ci-test-client
  #     │ ingress → echo.local:8080 (server entry_port) ──QUIC:10086──→ client
  #     │                                                                   │ egress
  #     │ egress  → 127.0.0.1:8081 (client http_entry_port)                │
  #     └─────────────────────────────────────────────────────────────────────→ backends
  #
  # Test order (external first, local second):
  #   SECTION 1 — External backends (continue-on-error)
  #     gRPC EchoService/Echo  — tunnel → grpc-echo.semior.dev:443
  #     gRPC EchoService/Echo  — direct connection (validates endpoint)
  #     HTTP GET/POST          — tunnel → beeceptor (429 accepted)
  #     WebSocket echo         — tunnel → echo.websocket.org
  #   SECTION 2 — HTTP/1.1 local (ingress + egress)
  #   SECTION 3 — HTTP/2 h2c upgrade (ingress + egress)
  #   SECTION 4 — WebSocket local
  #   SECTION 5 — gRPC Health local
  #   SECTION 6 — Bidirectional concurrent
  # ─────────────────────────────────────────────────────────────────────────────
  integration-test:
    name: Integration Test (all protocols)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build all binaries (server, client, ci-helpers)
        run: cargo build --release

      # /etc/hosts — map test domains to 127.0.0.1 so curl/ci-test-client use them
      - name: Configure /etc/hosts for test domains
        run: |
          sudo tee -a /etc/hosts << 'EOF'
          127.0.0.1  echo.local
          127.0.0.1  ws.local
          127.0.0.1  grpc.local
          127.0.0.1  echo.beeceptor.test
          127.0.0.1  ws.ext.test
          127.0.0.1  grpc.ext.test
          EOF

      # ─── Start local backend servers ─────────────────────────────────────────
      - name: Start http-echo-server (:9999)
        run: |
          ./target/release/http-echo-server 9999 > /tmp/http-echo.log 2>&1 &
          echo $! > /tmp/http-echo.pid
          for i in $(seq 1 10); do
            curl -sf http://127.0.0.1:9999/ > /dev/null && break; sleep 0.3
          done
          echo "http-echo-server ready"

      - name: Start ws-echo-server (:8765)
        run: |
          ./target/release/ws-echo-server 8765 > /tmp/ws-echo.log 2>&1 &
          echo $! > /tmp/ws-echo.pid
          sleep 1
          echo "ws-echo-server ready"

      - name: Start grpc-echo-server (:50051)
        run: |
          ./target/release/grpc-echo-server 50051 > /tmp/grpc-echo.log 2>&1 &
          echo $! > /tmp/grpc-echo.pid
          sleep 1
          echo "grpc-echo-server ready"

      # ─── Start tunnel ─────────────────────────────────────────────────────────
      - name: Start tunnel server
        run: |
          ./target/release/server --config ci-helpers/server.yaml \
            > /tmp/ci-server.log 2>&1 &
          echo $! > /tmp/server.pid
          sleep 2

      - name: Start tunnel client and wait for login
        run: |
          ./target/release/client --config ci-helpers/client.yaml \
            > /tmp/ci-client.log 2>&1 &
          echo $! > /tmp/client.pid
          for i in $(seq 1 30); do
            grep -q "Login successful" /tmp/ci-client.log 2>/dev/null && break
            sleep 0.5
          done
          if ! grep -q "Login successful" /tmp/ci-client.log; then
            echo "ERROR: client did not login"
            echo "=== server ===" && cat /tmp/ci-server.log
            echo "=== client ===" && cat /tmp/ci-client.log
            exit 1
          fi
          echo "Client connected and logged in"

      # ═══════════════════════════════════════════════════════════════════════════
      #  SECTION 1 — External backends (continue-on-error: real internet services)
      #              Tested FIRST to validate basic tunnel connectivity quickly.
      # ═══════════════════════════════════════════════════════════════════════════

      - name: "[Ext-gRPC] Echo/Ping — grpc.ext.test:8080 → grpc-echo.semior.dev:443"
        continue-on-error: true
        run: |
          ./target/release/ci-test-client grpc "grpc.ext.test:8080" --service ""

      - name: "[Ext-gRPC/Echo] EchoService/Echo — direct to grpc-echo.semior.dev:443"
        continue-on-error: true
        run: |
          ./target/release/ci-test-client grpc-echo "grpc-echo.semior.dev:443" \
            --tls --ping "ci-tunnel-ping"

      - name: "[Ext-HTTP] GET ingress — echo.beeceptor.test → beeceptor"
        continue-on-error: true
        run: |
          # 429 (rate limit) is expected and acceptable from beeceptor
          ./target/release/ci-test-client http "http://echo.beeceptor.test:8080/" \
            --allow-status 429

      - name: "[Ext-HTTP] POST body ingress — echo.beeceptor.test → beeceptor"
        continue-on-error: true
        run: |
          ./target/release/ci-test-client http "http://echo.beeceptor.test:8080/" \
            --method POST \
            --body '{"ci":"ext-post-test"}' \
            --allow-status 429

      - name: "[Ext-HTTP] GET egress — client:8081 → server → beeceptor"
        continue-on-error: true
        run: |
          ./target/release/ci-test-client http "http://127.0.0.1:8081/" \
            --header "Host: echo.free.beeceptor.com" \
            --allow-status 429

      - name: "[Ext-WS] Echo ingress — ws.ext.test → echo.websocket.org"
        continue-on-error: true
        run: |
          ./target/release/ci-test-client ws "ws://ws.ext.test:8080" --message "ext-ws-hello"

      - name: "[Ext-Bidir] 3 concurrent ingress + 3 concurrent egress"
        continue-on-error: true
        run: |
          for i in $(seq 1 3); do
            (./target/release/ci-test-client http "http://echo.beeceptor.test:8080/" \
               --allow-status 429 \
               > /tmp/ext-bidir-in-$i.txt 2>&1 && echo "in-$i:OK" || echo "in-$i:FAIL") &
            (./target/release/ci-test-client http "http://127.0.0.1:8081/" \
               --header "Host: echo.free.beeceptor.com" \
               --allow-status 429 \
               > /tmp/ext-bidir-eg-$i.txt 2>&1 && echo "eg-$i:OK" || echo "eg-$i:FAIL") &
          done
          wait
          FAIL=0
          for i in $(seq 1 3); do
            R_IN=$(tail -1 /tmp/ext-bidir-in-$i.txt); R_EG=$(tail -1 /tmp/ext-bidir-eg-$i.txt)
            echo "  $R_IN  |  $R_EG"
            echo "$R_IN" | grep -q "FAIL" && FAIL=$((FAIL+1)) || true
            echo "$R_EG" | grep -q "FAIL" && FAIL=$((FAIL+1)) || true
          done
          if [ "$FAIL" -gt 2 ]; then echo "FAIL: $FAIL/6"; exit 1; fi
          echo "PASS: $((6-FAIL))/6"

      # ═══════════════════════════════════════════════════════════════════════════
      #  SECTION 2 — HTTP/1.1 (local http-echo-server)
      # ═══════════════════════════════════════════════════════════════════════════

      - name: "[HTTP] 1.1 GET request — ingress (echo.local:8080)"
        run: |
          ./target/release/ci-test-client http "http://echo.local:8080/"

      - name: "[HTTP] 1.1 POST with JSON body — ingress"
        run: |
          ./target/release/ci-test-client http "http://echo.local:8080/" \
            --method POST \
            --body '{"tunnel":"ci","test":"post-body-123"}' \
            --expect-body "post-body-123"

      - name: "[HTTP] 1.1 Custom header forwarding — ingress"
        run: |
          ./target/release/ci-test-client http "http://echo.local:8080/" \
            --header "X-Tunnel-Test: reliable" \
            --expect-body "x-tunnel-test"

      - name: "[HTTP] 1.1 Connection-reuse timing (3 sequential GETs)"
        run: |
          echo "--- Connection reuse latency ---"
          for i in 1 2 3; do
            TIMING=$(curl -s -o /dev/null --max-time 15 \
              -w "connect=%{time_connect}s total=%{time_total}s code=%{http_code}" \
              http://echo.local:8080/ 2>&1)
            echo "  Req $i: $TIMING"
          done
          echo "PASS (latency logged above)"

      - name: "[HTTP] 1.1 Stability test (10 requests, >= 8 must succeed)"
        run: |
          OK=0
          for i in $(seq 1 10); do
            if ./target/release/ci-test-client http "http://echo.local:8080/" > /dev/null 2>&1; then
              printf "  OK(%s)" "$i"
              OK=$((OK+1))
            else
              printf "  FAIL(%s)" "$i"
            fi
          done
          echo ""
          if [ "$OK" -ge 8 ]; then
            echo "PASS: $OK/10 requests succeeded"
          else
            echo "FAIL: only $OK/10 requests succeeded (expected >= 8)"
            exit 1
          fi

      - name: "[HTTP] 1.1 GET — egress (client:8081 → server → http-echo)"
        run: |
          ./target/release/ci-test-client http "http://127.0.0.1:8081/" \
            --header "Host: echo.local"

      - name: "[HTTP] 1.1 POST body — egress"
        run: |
          ./target/release/ci-test-client http "http://127.0.0.1:8081/" \
            --method POST \
            --header "Host: echo.local" \
            --body '{"tunnel":"ci","test":"egress-post-456"}' \
            --expect-body "egress-post-456"

      # ═══════════════════════════════════════════════════════════════════════════
      #  SECTION 3 — HTTP/2 (h2c upgrade via HTTP/1.1 Upgrade header)
      #              Uses byte-level forwarding path (same as curl --http2).
      # ═══════════════════════════════════════════════════════════════════════════

      - name: "[HTTP2] h2c upgrade via entry port — ingress"
        run: |
          ./target/release/ci-test-client http2 "http://echo.local:8080/"

      - name: "[HTTP2] POST via h2c — ingress"
        run: |
          ./target/release/ci-test-client http2 "http://echo.local:8080/" \
            --method POST \
            --body '{"h2":"post-test"}' \
            --expect-body "post-test"

      - name: "[HTTP2] h2c via egress port — client:8081"
        run: |
          ./target/release/ci-test-client http2 "http://127.0.0.1:8081/" \
            --header "Host: echo.local"

      # ═══════════════════════════════════════════════════════════════════════════
      #  SECTION 4 — WebSocket
      # ═══════════════════════════════════════════════════════════════════════════

      - name: "[WS] Echo test — ingress (ws.local:8080 → ws-echo-server)"
        run: |
          ./target/release/ci-test-client ws "ws://ws.local:8080" --message "hello-ws-tunnel"

      - name: "[WS] Custom message — ingress"
        run: |
          ./target/release/ci-test-client ws "ws://ws.local:8080" --message "ci-msg-two"

      # ═══════════════════════════════════════════════════════════════════════════
      #  SECTION 5 — gRPC (via H2 proxy path)
      # ═══════════════════════════════════════════════════════════════════════════

      - name: "[gRPC] Health/Check (service='') — ingress (grpc.local:8080)"
        run: |
          ./target/release/ci-test-client grpc "grpc.local:8080" --service ""

      # ═══════════════════════════════════════════════════════════════════════════
      #  SECTION 6 — Bidirectional concurrent (local backends)
      # ═══════════════════════════════════════════════════════════════════════════

      - name: "[Bidir] 5 concurrent ingress + 5 concurrent egress (HTTP/1.1)"
        run: |
          for i in $(seq 1 5); do
            (./target/release/ci-test-client http "http://echo.local:8080/" \
               > /tmp/bidir-in-$i.txt 2>&1 && echo "in-$i:OK" >> /tmp/bidir-in-$i.txt \
               || echo "in-$i:FAIL" >> /tmp/bidir-in-$i.txt) &
            (./target/release/ci-test-client http "http://127.0.0.1:8081/" \
               --header "Host: echo.local" \
               > /tmp/bidir-eg-$i.txt 2>&1 && echo "eg-$i:OK" >> /tmp/bidir-eg-$i.txt \
               || echo "eg-$i:FAIL" >> /tmp/bidir-eg-$i.txt) &
          done
          wait
          FAIL=0
          for i in $(seq 1 5); do
            R_IN=$(tail -1 /tmp/bidir-in-$i.txt); R_EG=$(tail -1 /tmp/bidir-eg-$i.txt)
            echo "  $R_IN  |  $R_EG"
            echo "$R_IN" | grep -q "FAIL" && FAIL=$((FAIL+1)) || true
            echo "$R_EG" | grep -q "FAIL" && FAIL=$((FAIL+1)) || true
          done
          if [ "$FAIL" -gt 1 ]; then
            echo "FAIL: $FAIL/10 concurrent requests failed"
            exit 1
          fi
          echo "PASS: $((10-FAIL))/10 succeeded"

      - name: "[Bidir] Mixed protocols concurrent (HTTP1 + HTTP2 + WS — ingress)"
        run: |
          (./target/release/ci-test-client http "http://echo.local:8080/" \
             > /tmp/mixed-h1.txt 2>&1 && echo "h1:OK" || echo "h1:FAIL") >> /tmp/mixed-h1.txt &
          (./target/release/ci-test-client http2 "http://echo.local:8080/" \
             > /tmp/mixed-h2.txt 2>&1 && echo "h2:OK" || echo "h2:FAIL") >> /tmp/mixed-h2.txt &
          (./target/release/ci-test-client ws "ws://ws.local:8080" --message "concurrent-ws" \
             && echo "ws:OK" || echo "ws:FAIL") > /tmp/mixed-ws.txt 2>&1 &
          wait
          R_H1=$(tail -1 /tmp/mixed-h1.txt); R_H2=$(tail -1 /tmp/mixed-h2.txt); R_WS=$(tail -1 /tmp/mixed-ws.txt)
          echo "  $R_H1 | $R_H2 | $R_WS"
          echo "$R_H1$R_H2$R_WS" | grep -q "FAIL" && {
            echo "FAIL: at least one mixed-protocol request failed"
            exit 1
          }
          echo "PASS"

      # ─── Diagnostics ─────────────────────────────────────────────────────────
      - name: Upload logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ci-logs-${{ github.run_id }}
          path: |
            /tmp/ci-server.log
            /tmp/ci-client.log
            /tmp/http-echo.log
            /tmp/ws-echo.log
            /tmp/grpc-echo.log

      - name: Cleanup
        if: always()
        run: |
          kill "$(cat /tmp/server.pid    2>/dev/null)" 2>/dev/null || true
          kill "$(cat /tmp/client.pid    2>/dev/null)" 2>/dev/null || true
          kill "$(cat /tmp/http-echo.pid 2>/dev/null)" 2>/dev/null || true
          kill "$(cat /tmp/ws-echo.pid   2>/dev/null)" 2>/dev/null || true
          kill "$(cat /tmp/grpc-echo.pid 2>/dev/null)" 2>/dev/null || true
